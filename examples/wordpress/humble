#/bin/bash

#
# Docker Compose Wrapper
# ----------------------
# It helps to run overrides of a basic docker compose sourcing the informations
# from a local ".env" file.
#
#     // .env
#     PROJECT_ENV=default
#
#     // cli:
#     ./humble up --->
#     docker-compose -f docker-compose.yml up
#
# ----------------------
#     // .env
#     PROJECT_ENV=dev
#
#     // cli:
#     ./humble up --->
#     docker-compose -f docker-compose.yml -f docker-compose.dev.yml up
#
# NOTE:
# ".env" will be sourced into the "docker-compose.yml" file too,
# if you want to specify strings variables you need to export them:
#
#     export WEBSITE_TITLE="Just another Wordpress blog"
#


# Default name for the project environment description
# an optional override file is also loaded, the intention is to le the
# app to describe herself in the $ENV_CONFIG but some other changes
# can be injected from external services like the DockerProxy project.
ENV_CONFIG=.env
ENV_OVERRIDE=.env.override

# Validate environment
ENV_IS_VALID=false
[ -f $ENV_CONFIG ] && ENV_IS_VALID=true
[ -f $ENV_OVERRIDE ] && ENV_IS_VALID=true
if [ $ENV_IS_VALID == false ]; then
    echo "Please create a \".env\" file to describe your environment"
    exit 1
fi

# Command is mandatory
PROJECT_CMD=$1
if [[ -z $PROJECT_CMD ]]; then
    echo "Please input a command"
    echo "[$ALLOWED_COMMANDS]"
    exit 1
fi

# Compose the environment override string
# this will be passed to docker-compose instruction later on
ENV_OVERRIDE_VARS=""
if [ -f $ENV_OVERRIDE ]; then
    ENV_OVERRIDE_VARS=$(source $ENV_OVERRIDE && [[ ! -z ${PROJECT_ENV+x} ]] && ENV_OVERRIDE_VARS="$ENV_OVERRIDE_VARS PROJECT_ENV=$PROJECT_ENV" ; echo $ENV_OVERRIDE_VARS)
    ENV_OVERRIDE_VARS=$(source $ENV_OVERRIDE && [[ ! -z ${PROJECT_PORT+x} ]] && ENV_OVERRIDE_VARS="$ENV_OVERRIDE_VARS PROJECT_PORT=$PROJECT_PORT" ; echo $ENV_OVERRIDE_VARS)
    ENV_OVERRIDE_VARS=$(source $ENV_OVERRIDE && [[ ! -z ${PROJECT_HOST+x} ]] && ENV_OVERRIDE_VARS="$ENV_OVERRIDE_VARS PROJECT_HOST=$PROJECT_HOST" ; echo $ENV_OVERRIDE_VARS)
fi


# Get info about the current environment
[ -f $ENV_CONFIG ] && source $ENV_CONFIG
[ -f $ENV_OVERRIDE ] && source $ENV_OVERRIDE

# Load the optional override file
if [ -f $ENV_OVERRIDE ]; then
    source $ENV_OVERRIDE
fi

# Generate the compose override string
WHICH_COMPOSE=""
if [[ -f docker-compose.yml ]]; then
    WHICH_COMPOSE="-f docker-compose.yml"
fi
if [[ ! "default" == $PROJECT_ENV && ! -z $PROJECT_ENV ]]; then
    EXTEND_COMPOSE="docker-compose.$PROJECT_ENV.yml"
    if [ ! -f $EXTEND_COMPOSE ]; then
        echo "\"$EXTEND_COMPOSE\" not found!"
        exit 1
    fi
    WHICH_COMPOSE="$WHICH_COMPOSE -f $EXTEND_COMPOSE"
fi


# Compose the `docker-compose` full instruction
WHICH_DOCKER="$ENV_OVERRIDE_VARS docker-compose $WHICH_COMPOSE"
WHICH_CMD="$WHICH_DOCKER $@"

# Info
if [[ "info" == $PROJECT_CMD ]]; then
    echo ""
    echo ""
    echo ""
    echo "================================================="
    echo "=== COMPOSE PROJECT ============================="
    echo "================================================="
    echo ""
    echo "PROJECT_ENV: $PROJECT_ENV"
    echo "PROJECT_PORT: $PROJECT_PORT"
    echo "PROJECT_HOST: $PROJECT_HOST"
    echo ""
    echo ">> Full docker-compose command:"
    echo ""
    echo "    $WHICH_CMD"
    echo ""
    echo ""
    echo ""
    echo ""
    exit 0
fi



function getContainerId {
    echo $($WHICH_DOCKER ps -q $1)
}

function getContainerRunCmd {
    STATUS=$(docker inspect --format="{{ .State.Running }}" $1)
    if [[ "true" == $STATUS ]]; then
        echo "exec"
    else
        echo "run --rm"
    fi
}

function urlGetService {
    SERVICE="`echo $1 | grep '://' | sed -e's,^\(.*://\).*,\1,g'`"
    if [[ ! -z $SERVICE ]]; then
        echo ${SERVICE%???}
    fi
}

function urlGetPath {
    SERVICE="`echo $1 | grep '://' | sed -e's,^\(.*://\).*,\1,g'`"
    if [[ ! -z $SERVICE ]]; then
        echo "/"$1 | sed -e s,$SERVICE,,g
    fi
}

# Interface to `docker-utils` image
if [[ "utils" == $PROJECT_CMD ]]; then
    UTILS_CMD=$2

    if [[ "fs-dump" == $UTILS_CMD ]]; then
        BACKUP_ROOT=${FS_SEED_ROOT:-data/backup}

        # interpolate target service
        SERVICE_NAME=$(urlGetService $3)
        SERVICE_PATH=$(urlGetPath $3)
        SERVICE_CID=$(getContainerId $SERVICE_NAME)

        # compute backup file name
        BACKUP_DATE=$(date "+%Y%m%d-%H%M%S")
        BACKUP_NAME=$(echo $SERVICE_PATH | tr / .)
        BACKUP_NAME="$SERVICE_NAME""___""${BACKUP_NAME:1}___$BACKUP_DATE.tar.gz"
        BACKUP_NAME=${BACKUP_NAME//-./-}
        BACKUP_TARGET="$PWD/$BACKUP_ROOT"

        # make a nice backup structure
        SERVICE_PATH_DIRNAME=$(dirname $SERVICE_PATH)
        SERVICE_PATH_BASENAME=$(basename $SERVICE_PATH)

        eval "mkdir -p $BACKUP_TARGET && docker run --rm --volumes-from=$SERVICE_CID -v=$BACKUP_TARGET:/host-working-folder marcopeg/humble tar cvzf /host-working-folder/$BACKUP_NAME -C $SERVICE_PATH_DIRNAME ${SERVICE_PATH_BASENAME:-.}"
        exit
    fi

    if [[ "fs-seed" == $UTILS_CMD ]]; then
        BACKUP_ROOT=${FS_SEED_ROOT:-data/backup}
        BACKUP_FILE=${3:-$BACKUP_FILE}
        BACKUP_PATH="$PWD/$BACKUP_ROOT/$BACKUP_FILE"

        if [[ ! -f $BACKUP_PATH ]]; then
            echo "ERROR: Backup file does not exists!"
            exit
        fi

        # interpolate service string from backup file name
        SERVICE_STRING=$4
        if [[ "" == $SERVICE_STRING ]]; then
            SERVICE_STRING=$BACKUP_FILE
            SERVICE_STRING="`echo $SERVICE_STRING | grep '___' | sed -e's,^\(.*___\).*,\1,g'`"
            SERVICE_STRING="${SERVICE_STRING%???}"
            SERVICE_STRING=$(echo $SERVICE_STRING | tr . /)
            SERVICE_STRING="${SERVICE_STRING/___/://}"
        fi

        # interpolate target service
        SERVICE_NAME=$(urlGetService $SERVICE_STRING)
        SERVICE_PATH=$(urlGetPath $SERVICE_STRING)
        SERVICE_CID=$(getContainerId $SERVICE_NAME)

        eval "docker run --rm --volumes-from=$SERVICE_CID -v=$BACKUP_PATH:/host-backup-source marcopeg/humble sh -c \"mkdir -p $(dirname $SERVICE_PATH) && cd $(dirname $SERVICE_PATH) && tar xvfz /host-backup-source\""
        exit
    fi

    if [[ "fs-export" == $UTILS_CMD ]]; then
        SOURCE_SERVICE=$(urlGetService $3)
        SOURCE_PATH=$(urlGetPath $3)
        SOURCE_CID=$(getContainerId $SOURCE_SERVICE)
        TARGET_PATH="$PWD/$4"

        eval "mkdir -p $TARGET_PATH && docker run --rm --volumes-from=$SOURCE_CID -v=$TARGET_PATH:/host-working-folder marcopeg/humble cp -rf $SOURCE_PATH/. /host-working-folder"
        exit
    fi

    if [[ "fs-import" == $UTILS_CMD ]]; then
        TARGET_SERVICE=$(urlGetService $4)
        TARGET_PATH=$(urlGetPath $4)
        TARGET_CID=$(getContainerId $TARGET_SERVICE)

        eval "docker run --rm --volumes-from=$TARGET_CID -v="$PWD/$3":/host-working-folder marcopeg/humble cp -rf /host-working-folder/. $TARGET_PATH"
        exit
    fi

    # Run scripts from docker-utils image
    WHICH_CMD="$ENV_OVERRIDE_VARS docker-compose $WHICH_COMPOSE"
    EXEC_MODE=$(getContainerRunCmd $(getContainerId humble))
    TARGET_SCRIPT="${2-seed}.sh ${@:3}"
    WHICH_CMD="$WHICH_CMD $EXEC_MODE humble /bin/ash /scripts/$TARGET_SCRIPT"

    echo ""
    echo ">>> Docker Utils :: $TARGET_SCRIPT"
    echo ""
    echo ""
fi

# Wrap docker-compose commands
eval $WHICH_CMD
